1.What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def goodbye_world(n)
        puts "Goodbye World! #{n}"
    end
    
A. Constant Time Complexity: O(1) - this algorithm always take the same (constant) amount of time

2. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def find_largest(collection)
        largest = collection[0]
        collection.length.times do |i|
            if collection[i] >= largest
                largest = collection[i]
            end
        end
        largest
    end
    
A. Linear Time Complexity: O(n) - this is a linear seach, as the size of the collection grows, so will the length of the search

3. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def find_largest(collection)
        largest = collection[0][0]
        collection.length.times do |i|
            subcollection = collection[i]
            subcollection.length.times do |i|
                if subcollection[i] >= largest
                    largest = subcollection[i]
                end
            end
        end
        largest
    end
    
A. Linear Time Complexity: O(n) - this is a linear seach, as the size of the collection grows, so will the length of the search

4. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def numbers(n)
        if (n == 0)
            return 0
        elsif (n == 1)
            return 1
        else
            return numbers(n-1) + numbers(n-2)
        end
    end
    
A. Exponential Time Complexity: O(2^n) - As n grows, the number of computations that need to be made increased exponetially

5. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def iterative(n)
        num1 = 0
        num2 = 1
        i = 0
        while i < n-1
            tmp = num1 + num2
            num1 = num2
            num2 = tmp
            i+=1
        end
        num2
    end
    
A. Linear Time Complexity: O(n) - this is a linear seach, as the size of n grows, so will the length of the search

6. What's the Big-O of the following algorithm? Submit your work and reasoning with your solution.
    def sort(collection, from=0, to=nil)
        if to == nil
            to = collection.count - 1
        end
        
        if from >= to
            return
        end
        
        pivot = collection[from]
        min = from
        max = to
        
        free = min
        
        while min < max
            if free == min # Evaluate collection[max]
                if collection[max] <= pivot 
                    collection[free] = collection[max]
                    min += 1
                    free = max
                else
                    max -= 1
                end
            elsif free == max # Evaluate collection[min]
                if collection[min] >= pivot
                    collection[free] = collection[min]
                    max -= 1
                    free = min
                else
                    min += 1
                end
            else
                raise "Inconsistent state"
            end
        end
        
        collection[free] = pivot
        
        sort collection, from, free - 1
        sort collection, free + 1, to
        
        collection
    end
    
A. Exponential time: O(2^n)  -  The array splits it's self into two pieces then recursively calls upon itself for both pieces.